<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Графики мониторинга</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        .card {
            border-radius: 10px;
            border: 1px solid #dee2e6;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        .btn-group-wrap {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        #chartWrapper {
            position: relative;
            height: 450px;
            width: 100%;
        }

        [v-cloak] {
            display: none;
        }

        .loading-overlay {
            opacity: 0.5;
            pointer-events: none;
        }
    </style>
</head>
<body class="bg-light">
    <div id="app" class="container py-4" v-cloak>

        <div class="d-flex justify-content-between align-items-center mb-4">
            <h2 class="h4 mb-0">Графики состояния систем</h2>
            <a href="index.html" class="btn btn-outline-secondary btn-sm">← На главную</a>
        </div>

        <div class="card mb-4" :class="{'loading-overlay': loading}">
            <div class="card-body">
                <div class="row g-3 align-items-end">
                    <div class="col-md-4">
                        <label class="small fw-bold">С даты:</label>
                        <input type="datetime-local" v-model="filterFrom" class="form-control">
                    </div>
                    <div class="col-md-4">
                        <label class="small fw-bold">По дату:</label>
                        <input type="datetime-local" v-model="filterTo" class="form-control">
                    </div>
                    <div class="col-md-4">
                        <button @click="fetchData" class="btn btn-primary w-100" :disabled="loading">
                            <span v-if="loading" class="spinner-border spinner-border-sm me-1"></span>
                            {{ loading ? 'Загрузка...' : 'Обновить данные' }}
                        </button>
                    </div>
                </div>

                <div class="mt-4 pt-3 border-top" v-if="computerNames.length > 0">
                    <label class="small fw-bold d-block mb-2">Выберите компьютер:</label>
                    <div class="btn-group-wrap">
                        <button v-for="name in computerNames"
                                :key="name"
                                @click="selectComputer(name)"
                                :class="['btn btn-sm', selectedComputer === name ? 'btn-dark' : 'btn-outline-dark']">
                            {{ name }}
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <div class="card mb-4" v-if="availableSensors.length > 0">
            <div class="card-body">
                <label class="small fw-bold mb-2">Выберите сенсор:</label>
                <select class="form-select" v-model="selectedSensorKey" @change="updateChart">
                    <option :value="null" disabled>-- Выберите из списка --</option>
                    <optgroup v-for="(sensors, sysName) in groupedSensors" :key="sysName" :label="sysName">
                        <option v-for="s in sensors" :key="s.key" :value="s.key">
                            {{ s.sensorName }}
                        </option>
                    </optgroup>
                </select>
            </div>
        </div>

        <div class="card p-3" v-show="selectedSensorKey">
            <div id="chartWrapper">
                <canvas id="sensorChart"></canvas>
            </div>
        </div>

        <div v-if="!selectedSensorKey && availableSensors.length > 0" class="text-center py-5 text-muted">
            <p>Выберите датчик в списке выше, чтобы построить график</p>
        </div>

        <div v-if="rawData.length === 0 && !loading" class="alert alert-warning text-center">
            Данные не найдены. Проверьте подключение к API.
        </div>

    </div>
    <script>
        const { createApp } = Vue;

        createApp({
            data() {
                return {
                    rawData: [],
                    selectedComputer: null,
                    filterFrom: '',
                    filterTo: '',
                    selectedSensorKey: null,
                    chartInstance: null,
                    loading: false
                }
            },
            computed: {
                computerNames() {
                    return [...new Set(this.rawData.map(d => d.name))];
                },
                availableSensors() {
                    if (!this.selectedComputer) return [];
                    const sensorsMap = new Map();

                    this.rawData
                        .filter(d => d.name === this.selectedComputer)
                        .forEach(entry => {
                            if (entry.systems) {
                                entry.systems.forEach(sys => {
                                    if (sys.sensors) {
                                        sys.sensors.forEach(s => {
                                            const key = sys.name + '|' + s.name;
                                            if (!sensorsMap.has(key)) {
                                                sensorsMap.set(key, {
                                                    key,
                                                    systemName: sys.name,
                                                    sensorName: s.name
                                                });
                                            }
                                        });
                                    }
                                });
                            }
                        });
                    return Array.from(sensorsMap.values());
                },
                groupedSensors() {
                    const groups = {};
                    this.availableSensors.forEach(s => {
                        if (!groups[s.systemName]) groups[s.systemName] = [];
                        groups[s.systemName].push(s);
                    });
                    return groups;
                }
            },
            methods: {
                async fetchData() {
                    this.loading = true;
                    try {
                        const res = await fetch('/api/data');
                        if (!res.ok) throw new Error('Ошибка сервера');

                        this.rawData = await res.json();

                        // Если компьютер не выбран — выбираем первый
                        if (this.computerNames.length > 0 && !this.selectedComputer) {
                            this.selectedComputer = this.computerNames[0];
                        }

                        // Если сенсор уже выбран, обновляем график
                        if (this.selectedSensorKey) {
                            this.updateChart();
                        }
                    } catch (e) {
                        console.error("Data fetch error", e);
                        alert("Не удалось загрузить данные с сервера");
                    } finally {
                        this.loading = false;
                    }
                },
                selectComputer(name) {
                    this.selectedComputer = name;
                    this.selectedSensorKey = null;
                    if (this.chartInstance) {
                        this.chartInstance.destroy();
                        this.chartInstance = null;
                    }
                },
                updateChart() {
                    if (!this.selectedSensorKey) return;

                    const [sysName, sensName] = this.selectedSensorKey.split('|');
                    // Фильтрация данных на клиенте
                    let plotData = this.rawData
                        .filter(d => d.name === this.selectedComputer)
                        .filter(d => {
                            const t = new Date(d.time);
                            if (this.filterFrom && t < new Date(this.filterFrom)) return false;
                            if (this.filterTo && t > new Date(this.filterTo)) return false;
                            return true;
                        })
                        .sort((a, b) => new Date(a.time) - new Date(b.time));

                    const labels = plotData.map(d => {
                        const date = new Date(d.time);
                        return date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                    });

                    const values = plotData.map(d => {
                        const s = d.systems?.find(sys => sys.name === sysName)
                            ?.sensors?.find(sn => sn.name === sensName);
                        return s ? s.value : null;
                    });

                    this.renderChart(labels, values, sysName + ": " + sensName);
                },
                renderChart(labels, values, labelTitle) {
                    // Используем $nextTick чтобы Vue успел отобразить canvas в DOM
                    this.$nextTick(() => {
                        const ctx = document.getElementById('sensorChart');
                        if (!ctx) return;

                        if (this.chartInstance) {
                            this.chartInstance.destroy();
                        }

                        this.chartInstance = new Chart(ctx, {
                            type: 'line',
                            data: {
                                labels: labels,
                                datasets: [{
                                    label: labelTitle,
                                    data: values,
                                    borderColor: '#0d6efd',
                                    backgroundColor: 'rgba(13, 110, 253, 0.1)',
                                    fill: true,
                                    tension: 0.2,
                                    pointRadius: 3
                                }]
                            },
                            options: {
                                responsive: true,
                                maintainAspectRatio: false,
                                interaction: {
                                    intersect: false,
                                    mode: 'index'
                                },
                                scales: {
                                    y: { beginAtZero: false, title: { display: true, text: 'Значение' } },
                                    x: { ticks: { maxRotation: 45, minRotation: 45 } }
                                }
                            }
                        });
                    });
                }
            },
            mounted() {
                this.fetchData();
            }
        }).mount('#app');
    </script>
</body>
</html>